/**
 * tdesign v0.21.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var vue = require('vue');
var findIndex = require('lodash/findIndex');
var _common_js_log_log = require('../_common/js/log/log.js');
var upload_useUpload = require('./useUpload.js');
require('@babel/runtime/helpers/asyncToGenerator');
require('@babel/runtime/helpers/toConsumableArray');
require('@babel/runtime/regenerator');
require('lodash/isFunction');
require('lodash/without');
require('../config-provider/useConfig.js');
require('../config-provider/context.js');
require('lodash/mergeWith');
require('lodash/merge');
require('../_common/js/global-config/default-config.js');
require('../_common/js/global-config/locale/zh_CN.js');
require('./util.js');
require('../_common/js/upload/xhr.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var findIndex__default = /*#__PURE__*/_interopDefaultLegacy(findIndex);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var useComponentsStatus = function useComponentsStatus(props, uploadCtx) {
  var showUploadList = vue.computed(function () {
    if (props.multiple && props.theme === "file" && props.draggable) return true;
    return props.multiple && ["file-flow", "image-flow"].includes(props.theme);
  });
  var showTips = vue.computed(function () {
    if (props.theme === "file") {
      var hasNoFile = (!uploadCtx.uploadValue || !uploadCtx.uploadValue.length) && !uploadCtx.loadingFile;
      return props.tips && hasNoFile;
    }

    return Boolean(props.tips);
  });
  var showErrorMsg = vue.computed(function () {
    return !showUploadList.value && !!uploadCtx.errorMsg;
  });
  var singleDraggable = vue.computed(function () {
    return !props.multiple && props.draggable && ["file", "file-input", "image"].includes(props.theme);
  });
  return {
    showUploadList: showUploadList,
    showTips: showTips,
    showErrorMsg: showErrorMsg,
    singleDraggable: singleDraggable
  };
};
var useImgPreview = function useImgPreview(props) {
  var showImageViewUrl = vue.ref("");
  var showImageViewDialog = vue.ref(false);

  var handlePreviewImg = function handlePreviewImg(event, file) {
    var _props$onPreview;

    if (!file || !file.url) return _common_js_log_log["default"].error("Uploader", "Preview Error file");
    showImageViewUrl.value = file.url;
    showImageViewDialog.value = true;
    var previewCtx = {
      file: file,
      e: event
    };
    (_props$onPreview = props.onPreview) === null || _props$onPreview === void 0 ? void 0 : _props$onPreview.call(props, previewCtx);
  };

  var cancelPreviewImgDialog = function cancelPreviewImgDialog() {
    showImageViewDialog.value = false;
    var timer = setTimeout(function () {
      showImageViewUrl.value = null;
      clearTimeout(timer);
      timer = null;
    }, 500);
  };

  return {
    showImageViewUrl: showImageViewUrl,
    showImageViewDialog: showImageViewDialog,
    handlePreviewImg: handlePreviewImg,
    cancelPreviewImgDialog: cancelPreviewImgDialog
  };
};
var useDragger = function useDragger(props, disabled) {
  var dragActive = vue.ref(false);

  var handleDragenter = function handleDragenter(e) {
    var _props$onDragenter;

    if (disabled.value) return;
    dragActive.value = true;
    (_props$onDragenter = props.onDragenter) === null || _props$onDragenter === void 0 ? void 0 : _props$onDragenter.call(props, {
      e: e
    });
  };

  var handleDragleave = function handleDragleave(e) {
    var _props$onDragleave;

    if (disabled.value) return;
    dragActive.value = false;
    (_props$onDragleave = props.onDragleave) === null || _props$onDragleave === void 0 ? void 0 : _props$onDragleave.call(props, {
      e: e
    });
  };

  return {
    handleDragenter: handleDragenter,
    handleDragleave: handleDragleave,
    dragActive: dragActive
  };
};
var useRemove = function useRemove(props, uploadCtx) {
  var handleSingleRemove = function handleSingleRemove(e) {
    var _props$onRemove;

    var changeCtx = {
      trigger: "remove"
    };
    if (uploadCtx.loadingFile) uploadCtx.loadingFile = null;
    uploadCtx.errorMsg = "";
    uploadCtx.setUploadValue([], changeCtx);
    (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props, {
      e: e
    });
  };

  var handleFileInputRemove = function handleFileInputRemove(e) {
    e === null || e === void 0 ? void 0 : e.stopPropagation();
    handleSingleRemove(e);
  };

  var handleMultipleRemove = function handleMultipleRemove(options) {
    var _props$onRemove2;

    var files = [];

    if (!uploadCtx.canBatchUpload) {
      files = uploadCtx.uploadValue.concat();
      files.splice(options.index, 1);
    } else {
      files = [];
      options.files = uploadCtx.uploadValue.concat();
    }

    var changeCtx = _objectSpread({
      trigger: "remove"
    }, options);

    uploadCtx.setUploadValue(files, changeCtx);
    (_props$onRemove2 = props.onRemove) === null || _props$onRemove2 === void 0 ? void 0 : _props$onRemove2.call(props, options);
  };

  var handleListRemove = function handleListRemove(context) {
    var file = context.file;
    var index = findIndex__default["default"](uploadCtx.toUploadFiles, function (o) {
      return o.name === (file === null || file === void 0 ? void 0 : file.name);
    });

    if (index >= 0) {
      uploadCtx.toUploadFiles.splice(index, 1);
    } else {
      var index2 = findIndex__default["default"](uploadCtx.uploadValue, function (o) {
        return o.name === (file === null || file === void 0 ? void 0 : file.name);
      });
      handleMultipleRemove({
        e: context.e,
        index: index2
      });
    }
  };

  return {
    handleFileInputRemove: handleFileInputRemove,
    handleSingleRemove: handleSingleRemove,
    handleMultipleRemove: handleMultipleRemove,
    handleListRemove: handleListRemove
  };
};
var useActions = function useActions(props, uploadCtx, disabled) {
  var _useUpload = upload_useUpload.useUpload(props, uploadCtx),
      uploadFiles = _useUpload.uploadFiles,
      upload = _useUpload.upload,
      xhrReq = _useUpload.xhrReq;

  var inputRef = vue.ref(null);

  var handleChange = function handleChange(event) {
    var files = event.target.files;
    if (disabled.value) return;
    uploadFiles(files);
    inputRef.value.value = "";
  };

  var multipleUpload = function multipleUpload(currentFiles) {
    if (props.uploadAllFilesInOneRequest) {
      upload(currentFiles);
    } else {
      currentFiles.forEach(function (file) {
        upload(file);
      });
    }
  };

  var triggerUpload = function triggerUpload() {
    if (disabled.value) return;
    inputRef.value.click();
  };

  var cancelUpload = function cancelUpload() {
    if (uploadCtx.loadingFile) {
      var _props$onCancelUpload;

      if (!props.requestMethod) {
        xhrReq.value && xhrReq.value.abort();
        uploadCtx.toUploadFiles = [];
      }

      (_props$onCancelUpload = props.onCancelUpload) === null || _props$onCancelUpload === void 0 ? void 0 : _props$onCancelUpload.call(props);
      uploadCtx.loadingFile = null;
    }

    inputRef.value.value = "";
  };

  var handleDragChange = function handleDragChange(files) {
    if (disabled.value) return;
    uploadFiles(files);
  };

  return {
    handleChange: handleChange,
    multipleUpload: multipleUpload,
    triggerUpload: triggerUpload,
    cancelUpload: cancelUpload,
    handleDragChange: handleDragChange,
    upload: upload,
    inputRef: inputRef
  };
};
var useBatchUpload = function useBatchUpload(props) {
  var uploadInOneRequest = vue.computed(function () {
    return props.multiple && props.uploadAllFilesInOneRequest;
  });
  var canBatchUpload = vue.computed(function () {
    return uploadInOneRequest.value && props.isBatchUpload;
  });
  return {
    uploadInOneRequest: uploadInOneRequest,
    canBatchUpload: canBatchUpload
  };
};

exports.useActions = useActions;
exports.useBatchUpload = useBatchUpload;
exports.useComponentsStatus = useComponentsStatus;
exports.useDragger = useDragger;
exports.useImgPreview = useImgPreview;
exports.useRemove = useRemove;
//# sourceMappingURL=hooks.js.map
