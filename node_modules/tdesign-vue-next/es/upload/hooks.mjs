/**
 * tdesign v0.21.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../_chunks/dep-0b4c3c44.mjs';
import { computed, ref } from 'vue';
import '../_chunks/dep-a48de419.mjs';
import { d as _baseFindIndex } from '../_chunks/dep-c5bb3a66.mjs';
import { _ as _typeof } from '../_chunks/dep-7071345f.mjs';
import { d as _Stack } from '../_chunks/dep-2a7dc5c7.mjs';
import { _ as _baseIsEqual } from '../_chunks/dep-b4aa9d43.mjs';
import { i as isObject_1 } from '../_chunks/dep-d2403b2f.mjs';
import '../_chunks/dep-0b4185fe.mjs';
import { k as keys_1 } from '../_chunks/dep-10db0930.mjs';
import { g as get_1 } from '../_chunks/dep-6d14fb16.mjs';
import { h as hasIn_1 } from '../_chunks/dep-544fb8fd.mjs';
import { c as _isKey, b as _toKey, _ as _baseGet } from '../_chunks/dep-0c515b62.mjs';
import { i as identity_1 } from '../_chunks/dep-e769aafd.mjs';
import { i as isArray_1 } from '../_chunks/dep-3d4aad09.mjs';
import { _ as _baseProperty } from '../_chunks/dep-a25f46ac.mjs';
import { t as toInteger_1 } from '../_chunks/dep-3568c22b.mjs';
import '../_common/js/log/index.mjs';
import { useUpload } from './useUpload.mjs';
import log from '../_common/js/log/log.mjs';
import '../_chunks/dep-9311bf66.mjs';
import '../_chunks/dep-4889eb51.mjs';
import '../_chunks/dep-7922050a.mjs';
import '../_chunks/dep-3ca5fb38.mjs';
import '../_chunks/dep-169ea640.mjs';
import '../_chunks/dep-f6b25712.mjs';
import '../_chunks/dep-59545a4d.mjs';
import '../_chunks/dep-c27b1c14.mjs';
import '../_chunks/dep-7d96367f.mjs';
import '../_chunks/dep-827c4600.mjs';
import '../_chunks/dep-0820e0e2.mjs';
import '../_chunks/dep-caad2e91.mjs';
import '../_chunks/dep-8e38f523.mjs';
import '../_chunks/dep-469bf54b.mjs';
import '../_chunks/dep-83862ee1.mjs';
import '../_chunks/dep-ad0cc3b4.mjs';
import '../_chunks/dep-977c5cdd.mjs';
import '../_chunks/dep-a82b01df.mjs';
import '../_chunks/dep-192e10f1.mjs';
import '../_chunks/dep-050b3eb2.mjs';
import '../_chunks/dep-9262ea29.mjs';
import '../_chunks/dep-8c39d78a.mjs';
import '../_chunks/dep-556a2f2c.mjs';
import '../_chunks/dep-7ffddffa.mjs';
import '../_chunks/dep-8ef9fb8e.mjs';
import '../hooks/useConfig.mjs';
import '../config-provider/useConfig.mjs';
import '../_chunks/dep-bfb23a5e.mjs';
import '../_chunks/dep-400798c5.mjs';
import '../_chunks/dep-361522ee.mjs';
import '../_common/js/global-config/default-config.mjs';
import '../_common/js/global-config/locale/zh_CN.mjs';
import '../config-provider/type.mjs';
import './util.mjs';
import '../_common/js/upload/xhr.mjs';

var Stack = _Stack,
    baseIsEqual$1 = _baseIsEqual;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

var _baseIsMatch = baseIsMatch$1;

var isObject = isObject_1;
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable$2(value) {
  return value === value && !isObject(value);
}

var _isStrictComparable = isStrictComparable$2;

var isStrictComparable$1 = _isStrictComparable,
    keys = keys_1;
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData$1(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }

  return result;
}

var _getMatchData = getMatchData$1;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function matchesStrictComparable$2(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

var _matchesStrictComparable = matchesStrictComparable$2;

var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches$1(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches$1;

var baseIsEqual = _baseIsEqual,
    get = get_1,
    hasIn = hasIn_1,
    isKey$1 = _isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$1 = _toKey;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

var _baseMatchesProperty = baseMatchesProperty$1;

var baseGet = _baseGet;
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep$1(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep$1;

var baseProperty = _baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _isKey,
    toKey = _toKey;
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

var property_1 = property$1;

var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity = identity_1,
    isArray = isArray_1,
    property = property_1;
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee$1(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

var _baseIteratee = baseIteratee$1;

var baseFindIndex = _baseFindIndex,
    baseIteratee = _baseIteratee,
    toInteger = toInteger_1;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */

function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return -1;
  }

  var index = fromIndex == null ? 0 : toInteger(fromIndex);

  if (index < 0) {
    index = nativeMax(length + index, 0);
  }

  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

var findIndex_1 = findIndex;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var useComponentsStatus = function useComponentsStatus(props, uploadCtx) {
  var showUploadList = computed(function () {
    if (props.multiple && props.theme === "file" && props.draggable) return true;
    return props.multiple && ["file-flow", "image-flow"].includes(props.theme);
  });
  var showTips = computed(function () {
    if (props.theme === "file") {
      var hasNoFile = (!uploadCtx.uploadValue || !uploadCtx.uploadValue.length) && !uploadCtx.loadingFile;
      return props.tips && hasNoFile;
    }

    return Boolean(props.tips);
  });
  var showErrorMsg = computed(function () {
    return !showUploadList.value && !!uploadCtx.errorMsg;
  });
  var singleDraggable = computed(function () {
    return !props.multiple && props.draggable && ["file", "file-input", "image"].includes(props.theme);
  });
  return {
    showUploadList: showUploadList,
    showTips: showTips,
    showErrorMsg: showErrorMsg,
    singleDraggable: singleDraggable
  };
};
var useImgPreview = function useImgPreview(props) {
  var showImageViewUrl = ref("");
  var showImageViewDialog = ref(false);

  var handlePreviewImg = function handlePreviewImg(event, file) {
    var _props$onPreview;

    if (!file || !file.url) return log.error("Uploader", "Preview Error file");
    showImageViewUrl.value = file.url;
    showImageViewDialog.value = true;
    var previewCtx = {
      file: file,
      e: event
    };
    (_props$onPreview = props.onPreview) === null || _props$onPreview === void 0 ? void 0 : _props$onPreview.call(props, previewCtx);
  };

  var cancelPreviewImgDialog = function cancelPreviewImgDialog() {
    showImageViewDialog.value = false;
    var timer = setTimeout(function () {
      showImageViewUrl.value = null;
      clearTimeout(timer);
      timer = null;
    }, 500);
  };

  return {
    showImageViewUrl: showImageViewUrl,
    showImageViewDialog: showImageViewDialog,
    handlePreviewImg: handlePreviewImg,
    cancelPreviewImgDialog: cancelPreviewImgDialog
  };
};
var useDragger = function useDragger(props, disabled) {
  var dragActive = ref(false);

  var handleDragenter = function handleDragenter(e) {
    var _props$onDragenter;

    if (disabled.value) return;
    dragActive.value = true;
    (_props$onDragenter = props.onDragenter) === null || _props$onDragenter === void 0 ? void 0 : _props$onDragenter.call(props, {
      e: e
    });
  };

  var handleDragleave = function handleDragleave(e) {
    var _props$onDragleave;

    if (disabled.value) return;
    dragActive.value = false;
    (_props$onDragleave = props.onDragleave) === null || _props$onDragleave === void 0 ? void 0 : _props$onDragleave.call(props, {
      e: e
    });
  };

  return {
    handleDragenter: handleDragenter,
    handleDragleave: handleDragleave,
    dragActive: dragActive
  };
};
var useRemove = function useRemove(props, uploadCtx) {
  var handleSingleRemove = function handleSingleRemove(e) {
    var _props$onRemove;

    var changeCtx = {
      trigger: "remove"
    };
    if (uploadCtx.loadingFile) uploadCtx.loadingFile = null;
    uploadCtx.errorMsg = "";
    uploadCtx.setUploadValue([], changeCtx);
    (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props, {
      e: e
    });
  };

  var handleFileInputRemove = function handleFileInputRemove(e) {
    e === null || e === void 0 ? void 0 : e.stopPropagation();
    handleSingleRemove(e);
  };

  var handleMultipleRemove = function handleMultipleRemove(options) {
    var _props$onRemove2;

    var files = [];

    if (!uploadCtx.canBatchUpload) {
      files = uploadCtx.uploadValue.concat();
      files.splice(options.index, 1);
    } else {
      files = [];
      options.files = uploadCtx.uploadValue.concat();
    }

    var changeCtx = _objectSpread({
      trigger: "remove"
    }, options);

    uploadCtx.setUploadValue(files, changeCtx);
    (_props$onRemove2 = props.onRemove) === null || _props$onRemove2 === void 0 ? void 0 : _props$onRemove2.call(props, options);
  };

  var handleListRemove = function handleListRemove(context) {
    var file = context.file;
    var index = findIndex_1(uploadCtx.toUploadFiles, function (o) {
      return o.name === (file === null || file === void 0 ? void 0 : file.name);
    });

    if (index >= 0) {
      uploadCtx.toUploadFiles.splice(index, 1);
    } else {
      var index2 = findIndex_1(uploadCtx.uploadValue, function (o) {
        return o.name === (file === null || file === void 0 ? void 0 : file.name);
      });
      handleMultipleRemove({
        e: context.e,
        index: index2
      });
    }
  };

  return {
    handleFileInputRemove: handleFileInputRemove,
    handleSingleRemove: handleSingleRemove,
    handleMultipleRemove: handleMultipleRemove,
    handleListRemove: handleListRemove
  };
};
var useActions = function useActions(props, uploadCtx, disabled) {
  var _useUpload = useUpload(props, uploadCtx),
      uploadFiles = _useUpload.uploadFiles,
      upload = _useUpload.upload,
      xhrReq = _useUpload.xhrReq;

  var inputRef = ref(null);

  var handleChange = function handleChange(event) {
    var files = event.target.files;
    if (disabled.value) return;
    uploadFiles(files);
    inputRef.value.value = "";
  };

  var multipleUpload = function multipleUpload(currentFiles) {
    if (props.uploadAllFilesInOneRequest) {
      upload(currentFiles);
    } else {
      currentFiles.forEach(function (file) {
        upload(file);
      });
    }
  };

  var triggerUpload = function triggerUpload() {
    if (disabled.value) return;
    inputRef.value.click();
  };

  var cancelUpload = function cancelUpload() {
    if (uploadCtx.loadingFile) {
      var _props$onCancelUpload;

      if (!props.requestMethod) {
        xhrReq.value && xhrReq.value.abort();
        uploadCtx.toUploadFiles = [];
      }

      (_props$onCancelUpload = props.onCancelUpload) === null || _props$onCancelUpload === void 0 ? void 0 : _props$onCancelUpload.call(props);
      uploadCtx.loadingFile = null;
    }

    inputRef.value.value = "";
  };

  var handleDragChange = function handleDragChange(files) {
    if (disabled.value) return;
    uploadFiles(files);
  };

  return {
    handleChange: handleChange,
    multipleUpload: multipleUpload,
    triggerUpload: triggerUpload,
    cancelUpload: cancelUpload,
    handleDragChange: handleDragChange,
    upload: upload,
    inputRef: inputRef
  };
};
var useBatchUpload = function useBatchUpload(props) {
  var uploadInOneRequest = computed(function () {
    return props.multiple && props.uploadAllFilesInOneRequest;
  });
  var canBatchUpload = computed(function () {
    return uploadInOneRequest.value && props.isBatchUpload;
  });
  return {
    uploadInOneRequest: uploadInOneRequest,
    canBatchUpload: canBatchUpload
  };
};

export { useActions, useBatchUpload, useComponentsStatus, useDragger, useImgPreview, useRemove };
//# sourceMappingURL=hooks.mjs.map
