/**
 * tdesign v0.21.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _asyncToGenerator, r as regenerator } from '../_chunks/dep-9262ea29.mjs';
import { _ as _defineProperty } from '../_chunks/dep-0b4c3c44.mjs';
import { _ as _toConsumableArray } from '../_chunks/dep-8c39d78a.mjs';
import { ref } from 'vue';
import { i as isFunction_1 } from '../_chunks/dep-0b4185fe.mjs';
import '../_chunks/dep-a48de419.mjs';
import { _ as _baseDifference } from '../_chunks/dep-7ffddffa.mjs';
import { _ as _baseRest, i as isArrayLikeObject_1 } from '../_chunks/dep-8ef9fb8e.mjs';
import '../hooks/useConfig.mjs';
import { isOverSizeLimit } from './util.mjs';
import xhr from '../_common/js/upload/xhr.mjs';
import '../_common/js/log/index.mjs';
import log from '../_common/js/log/log.mjs';
import { useConfig } from '../config-provider/useConfig.mjs';
import '../_chunks/dep-7071345f.mjs';
import '../_chunks/dep-556a2f2c.mjs';
import '../_chunks/dep-3ca5fb38.mjs';
import '../_chunks/dep-d2403b2f.mjs';
import '../_chunks/dep-c5bb3a66.mjs';
import '../_chunks/dep-9311bf66.mjs';
import '../_chunks/dep-4889eb51.mjs';
import '../_chunks/dep-7922050a.mjs';
import '../_chunks/dep-169ea640.mjs';
import '../_chunks/dep-192e10f1.mjs';
import '../_chunks/dep-7d96367f.mjs';
import '../_chunks/dep-469bf54b.mjs';
import '../_chunks/dep-59545a4d.mjs';
import '../_chunks/dep-c27b1c14.mjs';
import '../_chunks/dep-e769aafd.mjs';
import '../_chunks/dep-0820e0e2.mjs';
import '../_chunks/dep-bfb23a5e.mjs';
import '../_chunks/dep-2a7dc5c7.mjs';
import '../_chunks/dep-f6b25712.mjs';
import '../_chunks/dep-827c4600.mjs';
import '../_chunks/dep-caad2e91.mjs';
import '../_chunks/dep-3d4aad09.mjs';
import '../_chunks/dep-8e38f523.mjs';
import '../_chunks/dep-400798c5.mjs';
import '../_chunks/dep-361522ee.mjs';
import '../_common/js/global-config/default-config.mjs';
import '../_common/js/global-config/locale/zh_CN.mjs';
import '../config-provider/type.mjs';

var baseDifference = _baseDifference,
    baseRest = _baseRest,
    isArrayLikeObject = isArrayLikeObject_1;
/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */

var without = baseRest(function (array, values) {
  return isArrayLikeObject(array) ? baseDifference(array, values) : [];
});
var without_1 = without;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var useUploadProgress = function useUploadProgress(props, uploadCtx) {
  var handleProgress = function handleProgress(_ref) {
    var _props$onProgress;

    var event = _ref.event,
        file = _ref.file,
        currentFiles = _ref.files,
        percent = _ref.percent,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? "real" : _ref$type;
    var innerFiles = Array.isArray(currentFiles) ? currentFiles : [file];
    if ((innerFiles === null || innerFiles === void 0 ? void 0 : innerFiles.length) <= 0) return log.error("Uploader", "Progress Error files");
    innerFiles.forEach(function (file2) {
      file2.percent = Math.min(percent, 100);
      uploadCtx.loadingFile = file2;
      uploadCtx.percent = file2.percent;
    });
    var progressCtx = {
      percent: percent,
      e: event,
      file: file,
      type: type,
      currentFiles: innerFiles
    };
    (_props$onProgress = props.onProgress) === null || _props$onProgress === void 0 ? void 0 : _props$onProgress.call(props, progressCtx);
  };

  var onError = function onError(options) {
    var _res, _props$onFail;

    var event = options.event,
        file = options.file,
        files = options.files,
        response = options.response,
        resFormatted = options.resFormatted;
    var innerFiles = Array.isArray(files) ? files : [file];
    innerFiles.forEach(function (file2) {
      file2.status = "fail";
      uploadCtx.loadingFile = file2;
    });
    var res = response;

    if (!resFormatted && typeof props.formatResponse === "function") {
      res = props.formatResponse(response, {
        file: file,
        currentFiles: files
      });
    }

    uploadCtx.errorMsg = (_res = res) === null || _res === void 0 ? void 0 : _res.error;
    var context = {
      e: event,
      file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
      currentFiles: innerFiles
    };
    (_props$onFail = props.onFail) === null || _props$onFail === void 0 ? void 0 : _props$onFail.call(props, context);
    uploadCtx.loadingFile = null;
  };

  var handleSuccess = function handleSuccess(_ref2) {
    var _res2, _props$onSuccess;

    var event = _ref2.event,
        file = _ref2.file,
        currentFiles = _ref2.files,
        response = _ref2.response;
    var innerFiles = Array.isArray(currentFiles) ? currentFiles : [file];
    if ((innerFiles === null || innerFiles === void 0 ? void 0 : innerFiles.length) <= 0) return log.error("Uploader", "success no files");
    innerFiles.forEach(function (file2) {
      file2.status = "success";
    });
    var res = response;

    if (typeof props.formatResponse === "function") {
      res = props.formatResponse(response, {
        file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
        currentFiles: innerFiles
      });
    }

    if ((_res2 = res) !== null && _res2 !== void 0 && _res2.error) {
      onError({
        event: event,
        file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
        files: innerFiles,
        response: res,
        resFormatted: true
      });
      return;
    }

    if (!uploadCtx.uploadInOneRequest) {
      innerFiles[0].url = res.url || innerFiles[0].url;
    }

    uploadCtx.toUploadFiles = without_1.apply(void 0, [uploadCtx.toUploadFiles].concat(_toConsumableArray(innerFiles)));
    var newFiles = innerFiles.map(function (file2) {
      return _objectSpread(_objectSpread({}, file2), {}, {
        response: res
      });
    });
    var uploadedFiles = props.multiple ? uploadCtx.uploadValue.concat(newFiles) : newFiles;
    var context = {
      e: event,
      response: res,
      trigger: "upload-success"
    };
    uploadCtx.setUploadValue(uploadedFiles, context);
    var sContext = {
      file: uploadCtx.uploadInOneRequest ? null : newFiles[0],
      fileList: uploadedFiles,
      currentFiles: newFiles,
      e: event,
      response: res
    };
    (_props$onSuccess = props.onSuccess) === null || _props$onSuccess === void 0 ? void 0 : _props$onSuccess.call(props, sContext);
    uploadCtx.loadingFile = null;
  };

  var handleMockProgress = function handleMockProgress(files) {
    var timer = setInterval(function () {
      files.forEach(function (file) {
        if (file.status === "success" || file.percent >= 99) {
          clearInterval(timer);
          return;
        }

        file.percent += 1;
      });
      var percent = files[0].percent;
      handleProgress({
        files: files,
        percent: percent,
        type: "mock"
      });
    }, 10);
  };

  return {
    handleProgress: handleProgress,
    handleMockProgress: handleMockProgress,
    handleSuccess: handleSuccess,
    onError: onError
  };
};
var useUpload = function useUpload(props, uploadCtx) {
  var xhrReq = ref(null);

  var _useConfig = useConfig("upload"),
      globalConfig = _useConfig.globalConfig,
      t = _useConfig.t;

  var _useUploadProgress = useUploadProgress(props, uploadCtx),
      handleProgress = _useUploadProgress.handleProgress,
      handleMockProgress = _useUploadProgress.handleMockProgress,
      handleSuccess = _useUploadProgress.handleSuccess,
      onError = _useUploadProgress.onError;

  var handleSizeLimit = function handleSizeLimit(fileSize) {
    var sizeLimit = typeof props.sizeLimit === "number" ? {
      size: props.sizeLimit,
      unit: "KB"
    } : props.sizeLimit;
    var rSize = isOverSizeLimit(fileSize / 1024, sizeLimit.size, sizeLimit.unit);

    if (!rSize) {
      uploadCtx.errorMsg = sizeLimit.message ? t(sizeLimit.message, {
        sizeLimit: sizeLimit.size
      }) : "".concat(t(globalConfig.value.sizeLimitMessage, {
        sizeLimit: sizeLimit.size
      }), " ").concat(sizeLimit.unit);
    }

    return rSize;
  };

  var handleBeforeUpload = function handleBeforeUpload(file) {
    uploadCtx.errorMsg = "";

    if (typeof props.beforeUpload === "function") {
      var r = props.beforeUpload(file);
      if (r instanceof Promise) return r;
      return new Promise(function (resolve) {
        return resolve(r);
      });
    }

    return new Promise(function (resolve) {
      if (props.sizeLimit) {
        resolve(handleSizeLimit(file.size));
      }

      resolve(true);
    });
  };

  var handleRequestMethodResponse = function handleRequestMethodResponse(res) {
    if (!res) {
      log.error("Upload", "`requestMethodResponse` is required.");
      return false;
    }

    if (!res.status) {
      log.error("Upload", "`requestMethodResponse.status` is missing, which value is `success` or `fail`");
      return false;
    }

    if (!["success", "fail"].includes(res.status)) {
      log.error("Upload", "`requestMethodResponse.status` must be `success` or `fail`");
      return false;
    }

    if (res.status === "success" && (!res.response || !res.response.url)) {
      log.warn("Upload", "`requestMethodResponse.response.url` is required, when `status` is `success`");
    }

    return true;
  };

  var handleRequestMethod = function handleRequestMethod(files) {
    if (!isFunction_1(props.requestMethod)) {
      log.warn("Upload", "`requestMethod` must be a function.");
      return;
    }

    var requestMethodParam = uploadCtx.uploadInOneRequest ? files : files[0];
    props.requestMethod(requestMethodParam).then(function (res) {
      if (!handleRequestMethodResponse(res)) return;

      if (res.status === "success") {
        handleSuccess({
          files: files,
          response: res.response
        });
      } else if (res.status === "fail") {
        var r = res.response || {};
        onError({
          event: null,
          file: uploadCtx.uploadInOneRequest ? null : files[0],
          files: files,
          response: _objectSpread(_objectSpread({}, r), {}, {
            error: res.error
          })
        });
      }
    });
  };

  var upload = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(currentFiles) {
      var innerFiles, request;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              innerFiles = Array.isArray(currentFiles) ? currentFiles : [currentFiles];

              if (!(!props.action && !props.requestMethod)) {
                _context.next = 4;
                break;
              }

              log.error("Upload", "one of action and requestMethod must be exist.");
              return _context.abrupt("return");

            case 4:
              innerFiles.forEach(function (file) {
                file.status = "progress";
                uploadCtx.loadingFile = file;
              });

              if (props.requestMethod) {
                handleRequestMethod(innerFiles);
              } else {
                if (props.useMockProgress) {
                  handleMockProgress(innerFiles);
                }

                request = xhr;
                xhrReq.value = request({
                  action: props.action,
                  data: props.data,
                  files: innerFiles,
                  name: props.name,
                  headers: props.headers,
                  withCredentials: props.withCredentials,
                  onError: onError,
                  onProgress: handleProgress,
                  onSuccess: handleSuccess,
                  method: props.method
                });
              }

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function upload(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  var uploadFiles = function uploadFiles(files) {
    var _uploadCtx$uploadValu, _props$onSelectChange;

    if (uploadCtx.canBatchUpload && ((_uploadCtx$uploadValu = uploadCtx.uploadValue) === null || _uploadCtx$uploadValu === void 0 ? void 0 : _uploadCtx$uploadValu.length) > 0) {
      var context = {
        trigger: "batch-clear"
      };
      uploadCtx.setUploadValue([], context);
    }

    (_props$onSelectChange = props.onSelectChange) === null || _props$onSelectChange === void 0 ? void 0 : _props$onSelectChange.call(props, _toConsumableArray(files));

    var tmpFiles = _toConsumableArray(files);

    if (props.max) {
      tmpFiles = tmpFiles.slice(0, props.max - uploadCtx.uploadValue.length);

      if (tmpFiles.length !== files.length) {
        console.warn("TDesign Upload Warn: you can only upload ".concat(props.max, " files"));
      }
    }

    tmpFiles.forEach(function (fileRaw) {
      var file = fileRaw;

      if (typeof props.format === "function") {
        file = props.format(fileRaw);
      }

      var uploadFile = _objectSpread({
        raw: fileRaw,
        lastModified: fileRaw.lastModified,
        name: fileRaw.name,
        size: fileRaw.size,
        type: fileRaw.type,
        percent: 0,
        status: "waiting"
      }, file);

      var reader = new FileReader();
      reader.readAsDataURL(fileRaw);

      reader.onload = function (event) {
        uploadFile.url = event.target.result;
      };

      handleBeforeUpload(file).then(function (canUpload) {
        if (!canUpload) return;
        var newFiles = uploadCtx.toUploadFiles.concat();

        if (props.allowUploadDuplicateFile || !uploadCtx.toUploadFiles.find(function (file2) {
          return file2.name === uploadFile.name;
        })) {
          newFiles.push(uploadFile);
        }

        uploadCtx.toUploadFiles = _toConsumableArray(new Set(newFiles));
        uploadCtx.loadingFile = uploadFile;

        if (props.autoUpload) {
          upload(uploadFile);
        }
      });
    });
  };

  return {
    uploadFiles: uploadFiles,
    upload: upload,
    xhrReq: xhrReq
  };
};

export { useUpload, useUploadProgress };
//# sourceMappingURL=useUpload.mjs.map
