/**
 * tdesign v0.21.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../_chunks/dep-dcf624da.mjs';
import { _ as _defineProperty } from '../_chunks/dep-0b4c3c44.mjs';
import { reactive, computed, toRefs, watch, nextTick } from 'vue';
import '../_chunks/dep-a48de419.mjs';
import { _ as _baseIsEqual } from '../_chunks/dep-b4aa9d43.mjs';
import { i as isFunction_1 } from '../_chunks/dep-0b4185fe.mjs';
import { TreeStore } from '../_common/js/tree/tree-store.mjs';
import { useFormDisabled } from '../form/hooks.mjs';
import useVModel from '../hooks/useVModel.mjs';
import useDefaultValue from '../hooks/useDefaultValue.mjs';
import { getTreeValue, isValueInvalid, isEmptyValues, getCascaderValue } from './core/helper.mjs';
import { treeNodesEffect, treeStoreExpendEffect } from './core/effect.mjs';
import '../_chunks/dep-556a2f2c.mjs';
import '../_chunks/dep-2a7dc5c7.mjs';
import '../_chunks/dep-9311bf66.mjs';
import '../_chunks/dep-4889eb51.mjs';
import '../_chunks/dep-7922050a.mjs';
import '../_chunks/dep-3ca5fb38.mjs';
import '../_chunks/dep-7071345f.mjs';
import '../_chunks/dep-d2403b2f.mjs';
import '../_chunks/dep-169ea640.mjs';
import '../_chunks/dep-f6b25712.mjs';
import '../_chunks/dep-59545a4d.mjs';
import '../_chunks/dep-c27b1c14.mjs';
import '../_chunks/dep-7d96367f.mjs';
import '../_chunks/dep-827c4600.mjs';
import '../_chunks/dep-0820e0e2.mjs';
import '../_chunks/dep-caad2e91.mjs';
import '../_chunks/dep-3d4aad09.mjs';
import '../_chunks/dep-8e38f523.mjs';
import '../_chunks/dep-469bf54b.mjs';
import '../_chunks/dep-c5bb3a66.mjs';
import '../_chunks/dep-10db0930.mjs';
import '../_chunks/dep-ad0cc3b4.mjs';
import '../_chunks/dep-83862ee1.mjs';
import '../_chunks/dep-84a9ab7d.mjs';
import '../_chunks/dep-7ffddffa.mjs';
import '../_chunks/dep-192e10f1.mjs';
import '../_chunks/dep-72359af2.mjs';
import '../_chunks/dep-e769aafd.mjs';
import '../_chunks/dep-8ef9fb8e.mjs';
import '../_chunks/dep-8e451077.mjs';
import '../_chunks/dep-a82b01df.mjs';
import '../_chunks/dep-977c5cdd.mjs';
import '../_chunks/dep-755716aa.mjs';
import '../_chunks/dep-82798823.mjs';
import '../_chunks/dep-52cbb58a.mjs';
import '../_chunks/dep-db11154e.mjs';
import '../_chunks/dep-400798c5.mjs';
import '../_common/js/tree/tree-node.mjs';
import '../_chunks/dep-9262ea29.mjs';
import '../_chunks/dep-8c39d78a.mjs';
import '../_chunks/dep-88e40e6a.mjs';
import '../_chunks/dep-6d14fb16.mjs';
import '../_chunks/dep-0c515b62.mjs';
import '../_common/js/tree/tree-node-model.mjs';
import '../_chunks/dep-32e8a48d.mjs';
import '../_chunks/dep-759eacca.mjs';
import '../_chunks/dep-544fb8fd.mjs';
import '../_chunks/dep-f1423dd2.mjs';
import '../_chunks/dep-efb50e88.mjs';
import '../_common/js/log/log.mjs';
import '../_chunks/dep-baa4f9dc.mjs';
import '../_chunks/dep-40522c7c.mjs';
import '../_chunks/dep-869cd310.mjs';
import '../_chunks/dep-ef911020.mjs';

var baseIsEqual = _baseIsEqual;
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */

function isEqual(value, other) {
  return baseIsEqual(value, other);
}

var isEqual_1 = isEqual;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var useContext = function useContext(props, setInnerValue, innerPopupVisible, setPopupVisible) {
  var statusContext = reactive({
    treeStore: null,
    inputVal: null,
    scopeVal: void 0,
    treeNodes: [],
    expend: []
  });
  return {
    statusContext: statusContext,
    cascaderContext: computed(function () {
      var size = props.size,
          checkStrictly = props.checkStrictly,
          lazy = props.lazy,
          multiple = props.multiple,
          filterable = props.filterable,
          clearable = props.clearable,
          checkProps = props.checkProps,
          max = props.max,
          disabled = props.disabled,
          showAllLevels = props.showAllLevels,
          minCollapsedNum = props.minCollapsedNum,
          valueType = props.valueType;
      return _objectSpread(_objectSpread({
        value: statusContext.scopeVal,
        size: size,
        checkStrictly: checkStrictly,
        lazy: lazy,
        multiple: multiple,
        filterable: filterable,
        clearable: clearable,
        checkProps: checkProps,
        max: max,
        disabled: disabled,
        showAllLevels: showAllLevels,
        minCollapsedNum: minCollapsedNum,
        valueType: valueType,
        visible: innerPopupVisible.value
      }, statusContext), {}, {
        setTreeNodes: function setTreeNodes(nodes) {
          statusContext.treeNodes = nodes;
        },
        setValue: function setValue(val, source, node) {
          if (isEqual_1(val, statusContext.scopeVal)) return;
          setInnerValue(val, {
            source: source,
            node: node
          });
        },
        setVisible: setPopupVisible,
        setInputVal: function setInputVal(val) {
          statusContext.inputVal = val;
        },
        setExpend: function setExpend(val) {
          statusContext.expend = val;
        }
      });
    })
  };
};
var useCascaderContext = function useCascaderContext(props) {
  var disabled = useFormDisabled();

  var _toRefs = toRefs(props),
      value = _toRefs.value,
      modelValue = _toRefs.modelValue,
      popupVisible = _toRefs.popupVisible;

  var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
      _useVModel2 = _slicedToArray(_useVModel, 2),
      innerValue = _useVModel2[0],
      setInnerValue = _useVModel2[1];

  var _useDefaultValue = useDefaultValue(popupVisible, false, props.onPopupVisibleChange, "popupVisible"),
      _useDefaultValue2 = _slicedToArray(_useDefaultValue, 2),
      innerPopupVisible = _useDefaultValue2[0],
      setPopupVisible = _useDefaultValue2[1];

  var _useContext = useContext(props, setInnerValue, innerPopupVisible, setPopupVisible),
      cascaderContext = _useContext.cascaderContext,
      statusContext = _useContext.statusContext;

  var isFilterable = computed(function () {
    return Boolean(props.filterable || isFunction_1(props.filter));
  });

  var updatedTreeNodes = function updatedTreeNodes() {
    var _cascaderContext$valu = cascaderContext.value,
        inputVal = _cascaderContext$valu.inputVal,
        treeStore = _cascaderContext$valu.treeStore,
        setTreeNodes = _cascaderContext$valu.setTreeNodes;
    treeNodesEffect(inputVal, treeStore, setTreeNodes, props.filter);
  };

  var updateExpend = function updateExpend() {
    var _cascaderContext$valu2 = cascaderContext.value,
        value2 = _cascaderContext$valu2.value,
        treeStore = _cascaderContext$valu2.treeStore;
    var expend = statusContext.expend;
    treeStoreExpendEffect(treeStore, value2, expend);
    treeStore.replaceChecked(getTreeValue(value2));
  };

  watch(function () {
    return props.options;
  }, function () {
    var options = props.options,
        _props$keys = props.keys,
        keys = _props$keys === void 0 ? {} : _props$keys,
        checkStrictly = props.checkStrictly,
        lazy = props.lazy,
        load = props.load,
        valueMode = props.valueMode;
    var treeStore = statusContext.treeStore;
    if (!options.length && !treeStore) return;

    if (!treeStore) {
      var store = new TreeStore({
        keys: _objectSpread(_objectSpread({}, keys), {}, {
          children: typeof keys.children === "string" ? keys.children : "children"
        }),
        checkable: true,
        expandMutex: true,
        expandParent: true,
        lazy: lazy,
        load: load,
        valueMode: valueMode,
        checkStrictly: checkStrictly,
        onLoad: function onLoad() {
          nextTick(function () {
            store.refreshNodes();
            updatedTreeNodes();
          });
        }
      });
      store.append(options);
      statusContext.treeStore = store;
    } else {
      if (isEqual_1(treeStore.config.options, options)) return;
      treeStore.reload(options);
      treeStore.refreshNodes();
    }

    updateExpend();
    updatedTreeNodes();
  }, {
    immediate: true
  });
  watch(function () {
    var checkStrictly = props.checkStrictly,
        lazy = props.lazy,
        load = props.load,
        valueMode = props.valueMode;
    return JSON.stringify({
      valueMode: valueMode,
      checkStrictly: checkStrictly,
      lazy: lazy,
      load: load
    });
  }, function () {
    var treeStore = statusContext.treeStore;
    if (!treeStore) return;
    var checkStrictly = props.checkStrictly,
        lazy = props.lazy,
        load = props.load,
        valueMode = props.valueMode;
    var treeProps = {
      checkStrictly: checkStrictly,
      disabled: disabled,
      load: load,
      lazy: lazy,
      valueMode: valueMode
    };
    treeStore.setConfig(treeProps);
  }, {
    immediate: true
  });
  watch(innerValue, function () {
    var _cascaderContext$valu3 = cascaderContext.value,
        setValue = _cascaderContext$valu3.setValue,
        multiple = _cascaderContext$valu3.multiple,
        valueType = _cascaderContext$valu3.valueType;

    if (isValueInvalid(innerValue.value, cascaderContext.value)) {
      setValue(multiple ? [] : "", "invalid-value");
    } else {
      statusContext.scopeVal = multiple ? [] : "";
    }

    if (!isEmptyValues(innerValue)) {
      statusContext.scopeVal = getCascaderValue(innerValue.value, valueType, multiple);
    }

    if (!statusContext.treeStore) return;
    updateExpend();
    updatedTreeNodes();
  }, {
    immediate: true
  });
  watch(function () {
    return innerPopupVisible.value && isFilterable.value;
  }, function (visible) {
    var setInputVal = cascaderContext.value.setInputVal;

    if (visible) {
      setInputVal("");
    }
  });
  watch(function () {
    return statusContext.inputVal;
  }, function () {
    updatedTreeNodes();
  });
  return {
    cascaderContext: cascaderContext,
    isFilterable: isFilterable
  };
};

export { useCascaderContext, useContext };
//# sourceMappingURL=hooks.mjs.map
