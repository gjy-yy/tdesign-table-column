/**
 * tdesign v0.21.1
 * (c) 2022 tdesign
 * @license MIT
 */

import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { ref } from 'vue';
import isFunction from 'lodash/isFunction';
import without from 'lodash/without';
import { useConfig } from '../config-provider/useConfig.js';
import { isOverSizeLimit } from './util.js';
import xhr from '../_common/js/upload/xhr.js';
import log from '../_common/js/log/log.js';
import '../config-provider/context.js';
import 'lodash/mergeWith';
import 'lodash/merge';
import '../_common/js/global-config/default-config.js';
import '../_common/js/global-config/locale/zh_CN.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var useUploadProgress = function useUploadProgress(props, uploadCtx) {
  var handleProgress = function handleProgress(_ref) {
    var _props$onProgress;

    var event = _ref.event,
        file = _ref.file,
        currentFiles = _ref.files,
        percent = _ref.percent,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? "real" : _ref$type;
    var innerFiles = Array.isArray(currentFiles) ? currentFiles : [file];
    if ((innerFiles === null || innerFiles === void 0 ? void 0 : innerFiles.length) <= 0) return log.error("Uploader", "Progress Error files");
    innerFiles.forEach(function (file2) {
      file2.percent = Math.min(percent, 100);
      uploadCtx.loadingFile = file2;
      uploadCtx.percent = file2.percent;
    });
    var progressCtx = {
      percent: percent,
      e: event,
      file: file,
      type: type,
      currentFiles: innerFiles
    };
    (_props$onProgress = props.onProgress) === null || _props$onProgress === void 0 ? void 0 : _props$onProgress.call(props, progressCtx);
  };

  var onError = function onError(options) {
    var _res, _props$onFail;

    var event = options.event,
        file = options.file,
        files = options.files,
        response = options.response,
        resFormatted = options.resFormatted;
    var innerFiles = Array.isArray(files) ? files : [file];
    innerFiles.forEach(function (file2) {
      file2.status = "fail";
      uploadCtx.loadingFile = file2;
    });
    var res = response;

    if (!resFormatted && typeof props.formatResponse === "function") {
      res = props.formatResponse(response, {
        file: file,
        currentFiles: files
      });
    }

    uploadCtx.errorMsg = (_res = res) === null || _res === void 0 ? void 0 : _res.error;
    var context = {
      e: event,
      file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
      currentFiles: innerFiles
    };
    (_props$onFail = props.onFail) === null || _props$onFail === void 0 ? void 0 : _props$onFail.call(props, context);
    uploadCtx.loadingFile = null;
  };

  var handleSuccess = function handleSuccess(_ref2) {
    var _res2, _props$onSuccess;

    var event = _ref2.event,
        file = _ref2.file,
        currentFiles = _ref2.files,
        response = _ref2.response;
    var innerFiles = Array.isArray(currentFiles) ? currentFiles : [file];
    if ((innerFiles === null || innerFiles === void 0 ? void 0 : innerFiles.length) <= 0) return log.error("Uploader", "success no files");
    innerFiles.forEach(function (file2) {
      file2.status = "success";
    });
    var res = response;

    if (typeof props.formatResponse === "function") {
      res = props.formatResponse(response, {
        file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
        currentFiles: innerFiles
      });
    }

    if ((_res2 = res) !== null && _res2 !== void 0 && _res2.error) {
      onError({
        event: event,
        file: uploadCtx.uploadInOneRequest ? null : innerFiles[0],
        files: innerFiles,
        response: res,
        resFormatted: true
      });
      return;
    }

    if (!uploadCtx.uploadInOneRequest) {
      innerFiles[0].url = res.url || innerFiles[0].url;
    }

    uploadCtx.toUploadFiles = without.apply(void 0, [uploadCtx.toUploadFiles].concat(_toConsumableArray(innerFiles)));
    var newFiles = innerFiles.map(function (file2) {
      return _objectSpread(_objectSpread({}, file2), {}, {
        response: res
      });
    });
    var uploadedFiles = props.multiple ? uploadCtx.uploadValue.concat(newFiles) : newFiles;
    var context = {
      e: event,
      response: res,
      trigger: "upload-success"
    };
    uploadCtx.setUploadValue(uploadedFiles, context);
    var sContext = {
      file: uploadCtx.uploadInOneRequest ? null : newFiles[0],
      fileList: uploadedFiles,
      currentFiles: newFiles,
      e: event,
      response: res
    };
    (_props$onSuccess = props.onSuccess) === null || _props$onSuccess === void 0 ? void 0 : _props$onSuccess.call(props, sContext);
    uploadCtx.loadingFile = null;
  };

  var handleMockProgress = function handleMockProgress(files) {
    var timer = setInterval(function () {
      files.forEach(function (file) {
        if (file.status === "success" || file.percent >= 99) {
          clearInterval(timer);
          return;
        }

        file.percent += 1;
      });
      var percent = files[0].percent;
      handleProgress({
        files: files,
        percent: percent,
        type: "mock"
      });
    }, 10);
  };

  return {
    handleProgress: handleProgress,
    handleMockProgress: handleMockProgress,
    handleSuccess: handleSuccess,
    onError: onError
  };
};
var useUpload = function useUpload(props, uploadCtx) {
  var xhrReq = ref(null);

  var _useConfig = useConfig("upload"),
      globalConfig = _useConfig.globalConfig,
      t = _useConfig.t;

  var _useUploadProgress = useUploadProgress(props, uploadCtx),
      handleProgress = _useUploadProgress.handleProgress,
      handleMockProgress = _useUploadProgress.handleMockProgress,
      handleSuccess = _useUploadProgress.handleSuccess,
      onError = _useUploadProgress.onError;

  var handleSizeLimit = function handleSizeLimit(fileSize) {
    var sizeLimit = typeof props.sizeLimit === "number" ? {
      size: props.sizeLimit,
      unit: "KB"
    } : props.sizeLimit;
    var rSize = isOverSizeLimit(fileSize / 1024, sizeLimit.size, sizeLimit.unit);

    if (!rSize) {
      uploadCtx.errorMsg = sizeLimit.message ? t(sizeLimit.message, {
        sizeLimit: sizeLimit.size
      }) : "".concat(t(globalConfig.value.sizeLimitMessage, {
        sizeLimit: sizeLimit.size
      }), " ").concat(sizeLimit.unit);
    }

    return rSize;
  };

  var handleBeforeUpload = function handleBeforeUpload(file) {
    uploadCtx.errorMsg = "";

    if (typeof props.beforeUpload === "function") {
      var r = props.beforeUpload(file);
      if (r instanceof Promise) return r;
      return new Promise(function (resolve) {
        return resolve(r);
      });
    }

    return new Promise(function (resolve) {
      if (props.sizeLimit) {
        resolve(handleSizeLimit(file.size));
      }

      resolve(true);
    });
  };

  var handleRequestMethodResponse = function handleRequestMethodResponse(res) {
    if (!res) {
      log.error("Upload", "`requestMethodResponse` is required.");
      return false;
    }

    if (!res.status) {
      log.error("Upload", "`requestMethodResponse.status` is missing, which value is `success` or `fail`");
      return false;
    }

    if (!["success", "fail"].includes(res.status)) {
      log.error("Upload", "`requestMethodResponse.status` must be `success` or `fail`");
      return false;
    }

    if (res.status === "success" && (!res.response || !res.response.url)) {
      log.warn("Upload", "`requestMethodResponse.response.url` is required, when `status` is `success`");
    }

    return true;
  };

  var handleRequestMethod = function handleRequestMethod(files) {
    if (!isFunction(props.requestMethod)) {
      log.warn("Upload", "`requestMethod` must be a function.");
      return;
    }

    var requestMethodParam = uploadCtx.uploadInOneRequest ? files : files[0];
    props.requestMethod(requestMethodParam).then(function (res) {
      if (!handleRequestMethodResponse(res)) return;

      if (res.status === "success") {
        handleSuccess({
          files: files,
          response: res.response
        });
      } else if (res.status === "fail") {
        var r = res.response || {};
        onError({
          event: null,
          file: uploadCtx.uploadInOneRequest ? null : files[0],
          files: files,
          response: _objectSpread(_objectSpread({}, r), {}, {
            error: res.error
          })
        });
      }
    });
  };

  var upload = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(currentFiles) {
      var innerFiles, request;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              innerFiles = Array.isArray(currentFiles) ? currentFiles : [currentFiles];

              if (!(!props.action && !props.requestMethod)) {
                _context.next = 4;
                break;
              }

              log.error("Upload", "one of action and requestMethod must be exist.");
              return _context.abrupt("return");

            case 4:
              innerFiles.forEach(function (file) {
                file.status = "progress";
                uploadCtx.loadingFile = file;
              });

              if (props.requestMethod) {
                handleRequestMethod(innerFiles);
              } else {
                if (props.useMockProgress) {
                  handleMockProgress(innerFiles);
                }

                request = xhr;
                xhrReq.value = request({
                  action: props.action,
                  data: props.data,
                  files: innerFiles,
                  name: props.name,
                  headers: props.headers,
                  withCredentials: props.withCredentials,
                  onError: onError,
                  onProgress: handleProgress,
                  onSuccess: handleSuccess,
                  method: props.method
                });
              }

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function upload(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  var uploadFiles = function uploadFiles(files) {
    var _uploadCtx$uploadValu, _props$onSelectChange;

    if (uploadCtx.canBatchUpload && ((_uploadCtx$uploadValu = uploadCtx.uploadValue) === null || _uploadCtx$uploadValu === void 0 ? void 0 : _uploadCtx$uploadValu.length) > 0) {
      var context = {
        trigger: "batch-clear"
      };
      uploadCtx.setUploadValue([], context);
    }

    (_props$onSelectChange = props.onSelectChange) === null || _props$onSelectChange === void 0 ? void 0 : _props$onSelectChange.call(props, _toConsumableArray(files));

    var tmpFiles = _toConsumableArray(files);

    if (props.max) {
      tmpFiles = tmpFiles.slice(0, props.max - uploadCtx.uploadValue.length);

      if (tmpFiles.length !== files.length) {
        console.warn("TDesign Upload Warn: you can only upload ".concat(props.max, " files"));
      }
    }

    tmpFiles.forEach(function (fileRaw) {
      var file = fileRaw;

      if (typeof props.format === "function") {
        file = props.format(fileRaw);
      }

      var uploadFile = _objectSpread({
        raw: fileRaw,
        lastModified: fileRaw.lastModified,
        name: fileRaw.name,
        size: fileRaw.size,
        type: fileRaw.type,
        percent: 0,
        status: "waiting"
      }, file);

      var reader = new FileReader();
      reader.readAsDataURL(fileRaw);

      reader.onload = function (event) {
        uploadFile.url = event.target.result;
      };

      handleBeforeUpload(file).then(function (canUpload) {
        if (!canUpload) return;
        var newFiles = uploadCtx.toUploadFiles.concat();

        if (props.allowUploadDuplicateFile || !uploadCtx.toUploadFiles.find(function (file2) {
          return file2.name === uploadFile.name;
        })) {
          newFiles.push(uploadFile);
        }

        uploadCtx.toUploadFiles = _toConsumableArray(new Set(newFiles));
        uploadCtx.loadingFile = uploadFile;

        if (props.autoUpload) {
          upload(uploadFile);
        }
      });
    });
  };

  return {
    uploadFiles: uploadFiles,
    upload: upload,
    xhrReq: xhrReq
  };
};

export { useUpload, useUploadProgress };
//# sourceMappingURL=useUpload.js.map
